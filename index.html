<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Canvas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #2a2a2a;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script type="module">
/* =========================
   FIREBASE SETUP (NEW)
========================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
    getFirestore,
    doc,
    getDoc,
    setDoc,
    arrayUnion,
    onSnapshot
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
    apiKey: "AIzaSyCnT3iX67G0jBJdyCRbDyXxM0Te5m1hY54",
    authDomain: "oneworld-ec021.firebaseapp.com",
    projectId: "oneworld-ec021",
    storageBucket: "oneworld-ec021.firebasestorage.app",
    messagingSenderId: "477814044122",
    appId: "1:477814044122:web:420b756e98923a1f64bce3"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* =========================
   CANVAS SETUP (UNCHANGED)
========================= */
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Canvas state
let offset = { x: 0, y: 0 };
let scale = 1;
let isDragging = false;
let dragStart = { x: 0, y: 0 };

// Persistent marks (NEW)
let marks = [];

/* =========================
   RENDERING
========================= */
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    render();
}

function render() {
    ctx.fillStyle = '#1e1e1e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);

    drawGrid();
    drawMarks();

    ctx.restore();
}

function drawGrid() {
    const gridSize = 50;
    const startX = Math.floor(-offset.x / scale / gridSize) * gridSize;
    const startY = Math.floor(-offset.y / scale / gridSize) * gridSize;
    const endX = startX + (canvas.width / scale) + gridSize;
    const endY = startY + (canvas.height / scale) + gridSize;

    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 1 / scale;

    for (let x = startX; x <= endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
    }

    for (let y = startY; y <= endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
    }
}

/* =========================
   MARKS (NEW)
========================= */
const DAY = 86400000;
const FADE_START = DAY;
const FADE_END = 30 * DAY;

function getMarkStyle(mark) {
    const age = Date.now() - mark.t;
    
    if (age < FADE_START) {
        return { alpha: 0.7, radius: 4 };
    }
    
    const fadeProgress = Math.min(1, (age - FADE_START) / (FADE_END - FADE_START));
    const alpha = 0.7 * (1 - fadeProgress);
    const radius = 4 * (1 - fadeProgress * 0.5);
    
    return { alpha, radius };
}

function drawMarks() {
    for (const m of marks) {
        const { alpha, radius } = getMarkStyle(m);
        
        if (alpha < 0.01) continue;
        
        if (m.trace) {
            // Memory dust - faint, irregular
            const seed = (m.x * 1000 + m.y) % 1;
            const markAlpha = (0.08 + seed * 0.12) * alpha;
            const markRadius = (2 + seed * 2.5) * (radius / 4);
            
            ctx.fillStyle = `rgba(200,190,180,${markAlpha})`;
            ctx.beginPath();
            ctx.arc(m.x, m.y, markRadius, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Primary marks - visible, intentional
            ctx.fillStyle = `rgba(220,220,220,${alpha * 0.6})`;
            ctx.beginPath();
            ctx.arc(m.x, m.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

/* =========================
   FIRESTORE: SINGLE TEST CHUNK
========================= */
const chunkRef = doc(db, "chunks", "0_0");

onSnapshot(chunkRef, (snap) => {
    if (snap.exists()) {
        marks = snap.data().marks || [];
    } else {
        marks = [];
    }
    render();
});

// Repaint to show aging
setInterval(render, 60000);

/* =========================
   INTERACTION
========================= */
let hasDragged = false;
let lastTraceTime = 0;
let lastTracePos = null;
let dragStartTime = 0;
let dragDistance = 0;
let canTrace = false;

canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    hasDragged = false;
    dragStart = { x: e.clientX - offset.x, y: e.clientY - offset.y };
    dragStartTime = Date.now();
    dragDistance = 0;
    canTrace = false;
    lastTracePos = null;
});

canvas.addEventListener('mousemove', (e) => {
    if (isDragging) {
        hasDragged = true;
        
        const prevOffsetX = offset.x;
        const prevOffsetY = offset.y;
        
        offset.x = e.clientX - dragStart.x;
        offset.y = e.clientY - dragStart.y;
        
        // Track distance in world space
        const dx = (offset.x - prevOffsetX) / scale;
        const dy = (offset.y - prevOffsetY) / scale;
        dragDistance += Math.sqrt(dx * dx + dy * dy);
        
        // Check if thresholds are met
        const dragDuration = Date.now() - dragStartTime;
        if (!canTrace && dragDuration > 100 && dragDistance > 10) {
            canTrace = true;
            const worldX = (e.clientX - offset.x) / scale;
            const worldY = (e.clientY - offset.y) / scale;
            lastTracePos = { x: worldX, y: worldY };
            lastTraceTime = Date.now();
            console.log('ðŸŸ¢ TRACE UNLOCKED - duration:', dragDuration, 'distance:', dragDistance.toFixed(1));
        }
        
        // Leave residue traces
        if (canTrace && lastTracePos) {
            const now = Date.now();
            const interval = 150 + Math.random() * 150;
            const timeSinceLastTrace = now - lastTraceTime;
            
            if (now - lastTraceTime > interval) {
                const worldX = (e.clientX - offset.x) / scale;
                const worldY = (e.clientY - offset.y) / scale;
                
                const dx = worldX - lastTracePos.x;
                const dy = worldY - lastTracePos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                console.log('â±ï¸ Trace check - time OK:', timeSinceLastTrace.toFixed(0), 'ms, distance:', dist.toFixed(1), 'units (need 2)');
                
                if (dist > 2) {
                    console.log('âœ… TRACE CREATED at', worldX.toFixed(1), worldY.toFixed(1));
                    // Add slight offset for organic feel
                    const offsetX = (Math.random() - 0.5) * 8;
                    const offsetY = (Math.random() - 0.5) * 8;
                    
                    const newMark = {
                        x: worldX + offsetX,
                        y: worldY + offsetY,
                        t: now,
                        trace: true
                    };
                    
                    lastTracePos = { x: worldX, y: worldY };
                    lastTraceTime = now;
                    
                    // Optimistically add to local array
                    marks.push(newMark);
                    
                    // Sync to Firestore
                    setDoc(chunkRef, {
                        marks: arrayUnion(newMark)
                    }, { merge: true }).catch(err => console.error('Firestore error:', err));
                } else {
                    console.log('âŒ Distance too small:', dist.toFixed(1));
                }
            } else {
                console.log('â³ Waiting for interval... (', timeSinceLastTrace.toFixed(0), '/', interval.toFixed(0), 'ms)');
            }
        } else if (isDragging) {
            console.log('ðŸ”’ Not eligible yet - duration:', dragDuration, 'ms, distance:', dragDistance.toFixed(1), 'units');
        }
        
        render();
    }
});

canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mouseleave', () => isDragging = false);

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();

    const mouseX = e.clientX;
    const mouseY = e.clientY;

    const worldX = (mouseX - offset.x) / scale;
    const worldY = (mouseY - offset.y) / scale;

    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    scale = Math.max(0.1, Math.min(10, scale * zoomFactor));

    offset.x = mouseX - worldX * scale;
    offset.y = mouseY - worldY * scale;

    render();
});

/* =========================
   CLICK â†’ MARK
========================= */
canvas.addEventListener("click", async (e) => {
    if (hasDragged) return;

    const worldX = (e.clientX - offset.x) / scale;
    const worldY = (e.clientY - offset.y) / scale;

    const newMark = {
        x: worldX,
        y: worldY,
        t: Date.now()
    };

    marks.push(newMark);
    render();

    setDoc(chunkRef, {
        marks: arrayUnion(newMark)
    }, { merge: true });
});

/* =========================
   INIT
========================= */
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
</script>
</body>
</html>
